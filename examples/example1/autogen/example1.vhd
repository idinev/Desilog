-----------------------------------------------------------
--------- AUTOGENERATED FILE, DO NOT EDIT -----------------
-----------------------------------------------------------

library ieee;
use ieee.std_logic_1164.all;
use ieee.numeric_std.all;
use work.desilog.all;


entity MySyncAdder is port(
	addClk_clk, addClk_reset_n: in std_ulogic;
	isAdd:	in std_ulogic; -- WIRE
	useOldZ_asX:	in std_ulogic; -- WIRE
	useOldZ_asY:	in std_ulogic; -- WIRE
	xx:	in u8; -- Latch
	yy:	in u8; -- Latch
	zz:	out u8 -- reg
	);
end entity;

library ieee;
use ieee.std_logic_1164.all;
use ieee.numeric_std.all;
use work.desilog.all;


entity MySyncLOP is port(
	lopClk_clk, lopClk_reset_n: in std_ulogic;
	oper:	in u4; -- reg
	rx:	in u8; -- reg
	ry:	in u8; -- reg
	xorMaskIdx:	in unsigned(2 downto 0); -- reg
	result:	out u8; -- reg
	lastAND:	out u8 -- Latch
	);
end entity;

library ieee;
use ieee.std_logic_1164.all;
use ieee.numeric_std.all;
use work.desilog.all;


entity Example1 is port(
	clk_clk, clk_reset_n: in std_ulogic;
	in_ry:	in u8; -- WIRE
	outa:	out u8; -- WIRE
	outb:	out u8 -- WIRE
	);
end entity;

library ieee;
use ieee.std_logic_1164.all;
use ieee.numeric_std.all;
use work.desilog.all;


--#------- MySyncAdder ------------------------------------
architecture rtl of MySyncAdder is

	----- internal regs/wires/etc --------
	signal dg_c_zz: u8;
	signal dg_o_zz: u8;
begin

	MyMainProcess: process (all)
		variable srcX: u8;
		variable srcY: u8;
	begin
		dg_c_zz <= dg_o_zz; -- reg preload
		srcX := X"00"; -- local-var zero-init
		srcY := X"00"; -- local-var zero-init
		if (useOldZ_asX = '1') then
			srcX := dg_o_zz;
		else
			srcX := yy;
		end if;
		if (useOldZ_asY = '1') then
			srcY := dg_o_zz;
		else
			srcY := xx;
		end if;
		if (isAdd = '1') then
			dg_c_zz <= (srcX + srcY);
		else
			dg_c_zz <= (srcX - srcY);
		end if;
	end process;

	----[ sync clock pump for addClk ]------
	process begin
		wait until rising_edge(addClk_clk);
		dg_o_zz <= dg_c_zz;
	end process;

	------[ output registers/wires/latches ] --------------
	zz <= dg_o_zz;
end;



library ieee;
use ieee.std_logic_1164.all;
use ieee.numeric_std.all;
use work.desilog.all;


--#------- MySyncLOP ------------------------------------
architecture rtl of MySyncLOP is
	signal ClockCounter: u32;	-- reg

	----- internal regs/wires/etc --------
	signal dg_c_oper: u4;
	signal dg_c_rx: u8;
	signal dg_c_ry: u8;
	signal dg_c_xorMaskIdx: unsigned(2 downto 0);
	signal dg_c_result: u8;
	signal dg_o_result: u8;
	signal dg_l_lastAND: u8;
	signal dg_c_ClockCounter: u32;
begin

	calcResult: process (all)
		variable xorRemap: unsigned(2 downto 0);
		variable xorMask: u8;
		variable tmpRes: u8;
	begin
		dg_c_result <= dg_o_result; -- reg preload
		dg_l_lastAND <= dg_l_lastAND; -- latch preload
		dg_c_ClockCounter <= ClockCounter; -- reg preload
		xorRemap := "000"; -- local-var zero-init
		xorMask := X"00"; -- local-var zero-init
		tmpRes := X"00"; -- local-var zero-init

		case xorMaskIdx is
			when "000" =>	xorRemap := "011";
			when "001" =>	xorRemap := "010";
			when "010" =>	xorRemap := "001";
			when "011" =>	xorRemap := "000";
			when "100" =>	xorRemap := "010";
			when others =>	xorRemap := "001";
		end case;

		case xorRemap is
			when "000" =>	xorMask := X"FF";
			when "001" =>	xorMask := X"11";
			when "010" | "100" | "111" =>	xorMask := X"33";
			when others => xorMask := X"00";
		end case;

		case oper is
			when X"0" =>	
				tmpRes := (rx and ry);
				dg_l_lastAND <= tmpRes;
			when X"1" =>	
				tmpRes := (rx or ry);
			when X"2" =>	
				tmpRes := (rx xor ry);
			when X"3" =>	
				tmpRes :=  (not (rx or ry));
			when others => null;
		end case;
		dg_c_result <= (tmpRes xor xorMask);
		dg_c_ClockCounter <= ClockCounter + X"00000001";
	end process;

	----[ sync clock pump for lopClk ]------
	process begin
		wait until rising_edge(lopClk_clk);
		dg_o_result <= dg_c_result;
		ClockCounter <= dg_c_ClockCounter;
		if lopClk_reset_n = '0' then
			dg_o_result <= X"99";
			ClockCounter <= X"00000100";
		end if;
	end process;

	------[ output registers/wires/latches ] --------------
	result <= dg_o_result;
	lastAND <= dg_l_lastAND;
end;



library ieee;
use ieee.std_logic_1164.all;
use ieee.numeric_std.all;
use work.desilog.all;


--#------- Example1 ------------------------------------
architecture rtl of Example1 is
	type MyFSM is (
		 MyFSM_init,
		 MyFSM_adding,
		 MyFSM_add_oldx,
		 MyFSM_add_oldy,
		 MyFSM_lopping);

	signal fsm: MyFSM;	-- reg
	signal count: u8;	-- reg

	----- internal regs/wires/etc --------
	signal dg_w_outa: u8;
	signal dg_w_outb: u8;
	signal dg_c_fsm: MyFSM;
	signal dg_c_count: u8;

	----- unit signals -------------
		signal adder_isAdd : std_ulogic;
		signal adder_useOldZ_asX : std_ulogic;
		signal adder_useOldZ_asY : std_ulogic;
		signal adder_xx : u8;
		signal adder_yy : u8;
		signal adder_zz : u8;
		signal lop_oper : u4;
		signal dg_c_lop_oper : u4;
		signal lop_rx : u8;
		signal dg_c_lop_rx : u8;
		signal lop_ry : u8;
		signal dg_c_lop_ry : u8;
		signal lop_xorMaskIdx : unsigned(2 downto 0);
		signal dg_c_lop_xorMaskIdx : unsigned(2 downto 0);
		signal lop_result : u8;
		signal lop_lastAND : u8;
		signal lop_lopClk_clk, lop_lopClk_reset_n : std_ulogic;

	function ChooseLOPOperation (counter : u8) return u4 is
		variable result: u4;
	begin
		result := X"0"; -- local-var zero-init

		case counter(1 downto 0) is
			when "00" =>	result := X"1";
			when "01" =>	result := X"2";
			when "10" =>	result := X"3";
			when others =>	result := X"0";
		end case;
		return result;
	end;
begin

	dg_comb_proc1: process (all)
	begin
		dg_w_outa <= X"00"; -- wire pre-zero-init
		dg_w_outb <= X"00"; -- wire pre-zero-init
		dg_w_outa <= adder_zz;
		dg_w_outb <= (lop_result + lop_lastAND);
	end process;

	main: process (all)
		variable resetCount: std_ulogic;
	begin
		dg_c_fsm <= fsm; -- reg preload
		dg_c_count <= count; -- reg preload
		adder_isAdd <= '0'; -- wire pre-zero-init
		adder_useOldZ_asX <= '0'; -- wire pre-zero-init
		adder_useOldZ_asY <= '0'; -- wire pre-zero-init
		adder_xx <= adder_xx; -- latch preload
		adder_yy <= adder_yy; -- latch preload
		dg_c_lop_oper <= lop_oper; -- reg preload
		dg_c_lop_rx <= lop_rx; -- reg preload
		dg_c_lop_xorMaskIdx <= lop_xorMaskIdx; -- reg preload
		resetCount := '0'; -- local-var zero-init

		case fsm is
			when MyFSM_init =>	
				dg_c_fsm <= MyFSM_adding;
				resetCount := '1';
				adder_yy <= in_ry;
			when MyFSM_adding =>	
				adder_isAdd <= '1';
				adder_xx <= count;
				if (dg_boolToBit(count = X"05") = '1') then
					dg_c_fsm <= MyFSM_add_oldx;
					resetCount := '1';
				end if;
			when MyFSM_add_oldx =>	
				adder_useOldZ_asX <= '1';
				if (dg_boolToBit(count = X"03") = '1') then
					dg_c_fsm <= MyFSM_add_oldy;
					resetCount := '1';
				end if;
			when MyFSM_add_oldy =>	
				adder_useOldZ_asY <= '1';
				adder_xx <= count;
				dg_c_fsm <= MyFSM_lopping;
				resetCount := '1';
			when MyFSM_lopping =>	
				dg_c_lop_oper <= ChooseLOPOperation(count);
				dg_c_lop_rx <= lop_rx + X"01";
				dg_c_lop_xorMaskIdx <= lop_xorMaskIdx - "001";
			when others => null;
		end case;
		if ((not clk_reset_n) = '1') then
			dg_c_lop_oper <= X"2";
		end if;
		if (resetCount = '1') then
			dg_c_count <= X"00";
		else
			dg_c_count <= (count + 1);
		end if;
	end process;

	-------[ sub-units ]-----------
	adder : entity work.MySyncAdder port map(
		addClk_clk => clk_clk,
		addClk_reset_n => clk_reset_n,
		isAdd => adder_isAdd,
		useOldZ_asX => adder_useOldZ_asX,
		useOldZ_asY => adder_useOldZ_asY,
		xx => adder_xx,
		yy => adder_yy,
		zz => adder_zz
	);
	lop : entity work.MySyncLOP port map(
		lopClk_clk => lop_lopClk_clk,
		lopClk_reset_n => lop_lopClk_reset_n,
		oper => lop_oper,
		rx => lop_rx,
		ry => lop_ry,
		xorMaskIdx => lop_xorMaskIdx,
		result => lop_result,
		lastAND => lop_lastAND
	);

	-------[ links ]----------
	lop_lopClk_clk <= clk_clk;
	lop_lopClk_reset_n <= clk_reset_n;

	----[ sync clock pump for clk ]------
	process begin
		wait until rising_edge(clk_clk);
		fsm <= dg_c_fsm;
		count <= dg_c_count;
		lop_oper <= dg_c_lop_oper;
		lop_rx <= dg_c_lop_rx;
		lop_ry <= dg_c_lop_ry;
		lop_xorMaskIdx <= dg_c_lop_xorMaskIdx;
		if clk_reset_n = '0' then
			fsm <= MyFSM_init;
		end if;
	end process;

	------[ output registers/wires/latches ] --------------
	outa <= dg_w_outa;
	outb <= dg_w_outb;
end;



